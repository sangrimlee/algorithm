---
id: '2818'
title: Apply Operations to Maximize Score
url: https://leetcode.com/problems/apply-operations-to-maximize-score
category: Algorithms
difficulty: Hard
tags:
  - Array
  - Math
  - Stack
  - Greedy
  - Sorting
  - Monotonic Stack
  - Number Theory
---

## ë¬¸ì œ ì„¤ëª…

- `n`ê°œì˜ ì–‘ì˜ ì •ìˆ˜ ë°°ì—´ `nums`ì™€ ì •ìˆ˜ `k`ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
- ì´ˆê¸° ì ìˆ˜ëŠ” `1`ì—ì„œ ì‹œì‘í•˜ë©°, **ìµœëŒ€ `k`ë²ˆì˜ ì—°ì‚°ì„ ìˆ˜í–‰**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ê° ì—°ì‚°ì—ì„œ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ë™ì‘ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
  1. ì´ì „ì— ì„ íƒí•˜ì§€ ì•Šì€ **ì–´ë–¤ ì—°ì†ëœ ë¶€ë¶„ ë°°ì—´** `nums[l, ..., r]`ì„ ì„ íƒí•©ë‹ˆë‹¤.
  2. í•´ë‹¹ ë¶€ë¶„ ë°°ì—´ì—ì„œ **ê°€ì¥ ë†’ì€ Prime Scoreë¥¼ ê°€ì§„ ìˆ«ì** `x`ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
     - ë§Œì•½ ê°™ì€ **Prime Score**ë¥¼ ê°€ì§„ ìˆ«ìê°€ ì—¬ëŸ¬ ê°œë¼ë©´, **ê°€ì¥ ì™¼ìª½ì˜ ìˆ«ìë¥¼ ì„ íƒ**í•©ë‹ˆë‹¤.
     - **Prime ScoreëŠ” ì†Œì¸ìˆ˜ì˜ ê°œìˆ˜ì™€ ê°™ìŠµë‹ˆë‹¤.**
       - ì˜ˆ) $300 = 2^2 \times 3 \times 5^2$ â†’ ì†Œì¸ìˆ˜ `{2, 3, 5}` â†’ **Prime Score = 3**
  3. í˜„ì¬ ì ìˆ˜ì— `x`ë¥¼ ê³±í•©ë‹ˆë‹¤.
- ìµœëŒ€ `k`ë²ˆì˜ ì—°ì‚° í›„, ìµœëŒ“ê°’ì„ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.
  - ìµœì¢… ê²°ê³¼ë¥¼ $10^9+7$ë¡œ ëª¨ë“ˆë ¤ ì—°ì‚°í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.

## ë¬¸ì œ í’€ì´

### **`Sieve of Eratosthenes & Sorting`**

> ğŸ’¡ í•µì‹¬ ì•„ì´ë””ì–´
>
> - **ì†Œìˆ˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ë¯¸ë¦¬ êµ¬í•´ì„œ ì†Œì¸ìˆ˜ ê°œìˆ˜ë¥¼ ë¹ ë¥´ê²Œ ê³„ì‚°**
> - **ìŠ¤íƒì„ ì´ìš©í•´ `prevDominant`ì™€ `nextDominant`ë¥¼ êµ¬í•´ ë¹ ë¥´ê²Œ ì„œë¸Œ ë°°ì—´ ê°œìˆ˜ ê³„ì‚°**
> - **í° ìˆ«ìë¶€í„° ì„ íƒí•˜ì—¬ `k`ë²ˆì˜ ì—°ì‚° ë‚´ì—ì„œ ìµœì ì˜ ê³±ì…ˆì„ ìˆ˜í–‰**

1. **ì†Œì¸ìˆ˜ ê°œìˆ˜(Prime Score) ê³„ì‚°**
   - ê°€ì¥ í° ìˆ«ì(`maxNum`)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ `findPrimes()`ë¥¼ ì‚¬ìš©í•´ **ì†Œìˆ˜ ë¦¬ìŠ¤íŠ¸**ë¥¼ êµ¬í•©ë‹ˆë‹¤.
   - `getPrimeScore()`ë¥¼ ì´ìš©í•´ `nums` ë°°ì—´ì˜ ê° ìˆ«ìì— ëŒ€í•œ **ì†Œì¸ìˆ˜ ê°œìˆ˜(Prime Score)**ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
2. **Dominant Index ê³„ì‚° (ì´ì „/ë‹¤ìŒ í° Prime Score ì°¾ê¸°)**
   - **ì˜¤ë¦„ì°¨ìˆœ ëª¨ë…¸í† ë‹‰ ìŠ¤íƒ**ì„ í™œìš©
     - `prevDominant[i]` â†’ `i` ì´ì „ì— ìˆëŠ” ë” í° Prime Scoreì˜ ì¸ë±ìŠ¤
     - `nextDominant[i]` â†’ `i` ì´í›„ì— ìˆëŠ” ë” í° Prime Scoreì˜ ì¸ë±ìŠ¤
   - ì´ë¥¼ ì´ìš©í•´, **ê° ìˆ«ìê°€ ì„ íƒë  ìˆ˜ ìˆëŠ” ëª¨ë“  ë¶€ë¶„ ë°°ì—´ ê°œìˆ˜**ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
3. **ê°€ëŠ¥í•œ ëª¨ë“  ë¶€ë¶„ ë°°ì—´ ê°œìˆ˜ êµ¬í•˜ê¸°**
   - `numOfSubarrays[i] = (nextDominant[i] - i) * (i - prevDominant[i])`
     - ì¦‰, `i`ë²ˆ ì¸ë±ìŠ¤ì˜ ìˆ«ìê°€ í¬í•¨ë  ìˆ˜ ìˆëŠ” ë¶€ë¶„ ë°°ì—´ì˜ ê°œìˆ˜ë¥¼ êµ¬í•©ë‹ˆë‹¤.
4. **ê°€ì¥ í° ìˆ«ìë¶€í„° ì„ íƒí•˜ì—¬ ê³±í•˜ê¸°**
   - `nums`ë¥¼ **ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬**í•˜ì—¬ ê°€ì¥ í° ìˆ«ìë¶€í„° ì„ íƒí•©ë‹ˆë‹¤.
   - ê°€ëŠ¥í•œ ì—°ì‚° íšŸìˆ˜(`k`)ë¥¼ ê³ ë ¤í•˜ë©´ì„œ, `power()`ë¥¼ ì´ìš©í•´ **ëª¨ë“ˆëŸ¬ ì—°ì‚° ê¸°ë°˜ ê³±ì…ˆ ì—°ì‚°**ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
5. **ìµœì¢… ê²°ê³¼ ë°˜í™˜**
   - ì—°ì‚°ì´ ì¢…ë£Œë˜ë©´ `score` ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   - **í° ìˆ˜ ì—°ì‚°ì´ í•„ìš”í•˜ë¯€ë¡œ `BigInt`ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“ˆëŸ¬ ì—°ì‚°ì„ ìµœì í™”**í•©ë‹ˆë‹¤.

```typescript showLineNumbers
const MOD = 10 ** 9 + 7;

export function maximumScore(nums: number[], k: number): number {
  const n = nums.length;
  const maxNum = nums.reduce((prev, num) => Math.max(prev, num), 0);
  const primes = findPrimes(maxNum);
  const primeScores = nums.map((num) => getPrimeScore(num, primes));
  const nextDominant = new Array<number>(n).fill(n);
  const prevDominant = new Array<number>(n).fill(-1);

  const stack: number[] = [];
  for (let i = 0; i < n; i++) {
    while (0 < stack.length && primeScores[stack[stack.length - 1]] < primeScores[i]) {
      const topIndex = stack.pop()!;
      nextDominant[topIndex] = i;
    }
    if (0 < stack.length) {
      prevDominant[i] = stack[stack.length - 1];
    }
    stack.push(i);
  }

  const numOfSubarrays = new Array<number>(n).fill(0);
  for (let i = 0; i < n; i++) {
    numOfSubarrays[i] = (nextDominant[i] - i) * (i - prevDominant[i]);
  }

  const sortedNums = nums.map((num, i) => [num, i]).sort((a, b) => b[0] - a[0]);
  let score = 1;
  let currentIndex = 0;
  let remainOperations = k;
  while (remainOperations > 0) {
    const [num, i] = sortedNums[currentIndex];
    currentIndex += 1;
    const operations = Math.min(remainOperations, numOfSubarrays[i]);
    score = multiply(score, power(num, operations));
    remainOperations -= operations;
  }
  return score;
}

function findPrimes(limit: number): number[] {
  const primes: number[] = [];
  const isPrime = new Array<boolean>(limit + 1).fill(true);
  for (let num = 2; num <= limit; num++) {
    if (!isPrime[num]) {
      continue;
    }
    primes.push(num);
    for (let mul = num * num; mul <= limit; mul += num) {
      isPrime[mul] = false;
    }
  }
  return primes;
}

function getPrimeScore(num: number, primes: number[]): number {
  let primeScore = 0;
  for (const prime of primes) {
    if (num < prime * prime) {
      break;
    }
    if (num % prime !== 0) {
      continue;
    }
    primeScore += 1;
    while (num % prime === 0) {
      num /= prime;
    }
  }
  return num > 1 ? primeScore + 1 : primeScore;
}

function multiply(num1: number, num2: number): number {
  return Number((BigInt(num1) * BigInt(num2)) % BigInt(MOD));
}

function power(base: number, exponent: number): number {
  let result = 1;
  while (exponent > 0) {
    if (exponent % 2 !== 0) {
      result = multiply(result, base);
    }
    base = multiply(base, base);
    exponent = Math.floor(exponent / 2);
  }
  return result % MOD;
}
```

#### ë³µì¡ë„

- $n$: `nums`ì˜ ê¸¸ì´, $m$: `nums`ì—ì„œ ê°€ì¥ í° ìˆ˜
- ì‹œê°„ ë³µì¡ë„: $O(n \times (log_2m + log_2n) + m \cdot log_2log_2m )$
- ê³µê°„ ë³µì¡ë„: $O(\max(m, n))$
